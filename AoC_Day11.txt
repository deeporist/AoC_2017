难得一逼啊
正六边形形成的网格, 从一个网格出发到邻近的六个网格
方向有六个
(n,s),(nw,se),(sw,ne)

然后是简化
每一个第二步 都有三个方向无法简化 三个方向可以简化
只能从全路径记录里一点一点删除无效行动

将方向数字化 将路径记录全部塞进int 数组处理
nw=1 n=2 ne=3
sw=4 s=5 se=6

保后不保前
3,5 -> 0,6
----------------
1,3 -> 2
1,5 -> 4
1,6 -> 0

2,4 -> 1
2,5 -> 0
2,6 -> 3

3,1 -> 2
3,4 -> 0
3,5 -> 6

4,2 -> 1
4,3 -> 0
4,6 -> 5

5,1 -> 4
5,2 -> 0
5,3 -> 6

6,1 -> 0
6,2 -> 3
6,4 -> 5
----------------
行动顺序无所谓1,3,1和1,1,3是一回事

1    2    3    4    5    6
1705 1222 1096 1484 1396 1320 (123456->0)
609  126       388  300  224  (12456->4)
483            388  174  98   (1456->45)
385            388  174       (145->44)
211            562            (14)            


求最远的一次   操
int rec[7]=0-6
每记录一个行动就对整个数组求一次值(max())
这尼玛不就是俄罗斯方块么(每一次的对角最多保留其中一个)
